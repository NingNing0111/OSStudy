# 操作系统大题复习

## 进程调度大题

- 先来先服务调度
- 短作业优先调度
- 高响应比优先调度
- 时间片调度算法
- 强占式/非抢占式短作业优先调度

### 题目一描述

假定在一个处理机上执行以下五个作业：

| 作业号 | 到达时间 | 运行时间 |
| ------ | -------- | -------- |
| A      | 0        | 4        |
| B      | 1        | 3        |
| C      | 2        | 5        |
| D      | 3        | 2        |
| E      | 4        | 4        |

(1)画出采用 FCFS 调度算法时调度图，并计算每个作业的周转时间和计算平均周转时间。
(2)画出采用 SJF 调度算法时调度图，并计算每个作业的周转时间和计算平均周转时间。
(3)写出采用 HRN（响应比高者优先）调度算法时选择作业号的次序和选择作业的依据（各作业的响应比）。
(4)时间片为 `q=1` 的调度算法，并计算每个作业的周转时间和平均周转时间;

### 1. 先来先服务

&emsp;到达顺序分别为：ABCDE。

| T    | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
| FCFS | A   | A   | A   | A   | B   | B   | B   | C   | C   | C   | C   | C   | D   | D   | E   | E   | E   | E   | Done |

| 进程编号 | 开始时间 | 结束时间 | 周转时间 | 带权周转     |
| -------- | -------- | -------- | -------- | ------------ |
| A        | 0        | 4        | 4-0=4    | 4 / 4 = 1    |
| B        | 1        | 7        | 7-1=6    | 6 / 3 = 2    |
| C        | 2        | 12       | 12-2=10  | 10 / 5 = 2   |
| D        | 3        | 14       | 14-3=11  | 11 / 2 = 5.5 |
| E        | 4        | 18       | 18-4=14  | 14 / 4 = 3.5 |

平均周转时间：`(4 + 6 + 10 + 11 + 14) / 5 = 9`
平均带权周转时间：`(1 + 2 + 2 + 5.5 + 3.5) / 5 = 2.8`

### 2. 短作业优先

- t = 0 时，A 到达，且运行时间最少，因此执行 A；Q{A(4)}
- t=1 时， B 到达，此时 A、B 运行时间均为 3 且均为最少，选择继续执行 A；Q{A(3),B(3)}
- t=2 时，C 到达，此时 A 最少，继续执行 A;Q{A(2),B(3),C(5)}
- t=3 时，D 到达，此时 A 最少，继续执行 A;Q{A(1),B(3),C(5),D(2)}
- t=4 时，E 到达，此时 A 执行完毕；Q{B(3),C(5),D(2),E(4)},选择最少的 D 执行；
- t=6 时，D 执行完毕；Q{B(3),C(5),E(4)}.
- t=9 时，B 执行完毕;
- t=13 时，E 执行完毕；
- t=18 时，C 执行完毕

| T   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
| SJF | A   | A   | A   | A   | D   | D   | B   | B   | B   | E   | E   | E   | E   | C   | C   | C   | C   | C   | Done |

| 进程编号 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| -------- | -------- | -------- | -------- | ------------ |
| A        | 0        | 4        | 4-0=4    | 4 / 4        |
| B        | 1        | 9        | 9-1=8    | 8 / 3        |
| C        | 2        | 18       | 18-2=16  | 16 / 5       |
| D        | 3        | 6        | 6-3=3    | 3 / 2        |
| E        | 4        | 13       | 13-4=9   | 9/4          |

平均周转时间：`(4 + 8 + 16 + 3 + 9) / 5 = 8`

### 3. 高响应比优先

&emsp;公式：

$$
    R_p = 	\frac{(T_{wait} + T_{needService})}{T_{needService}} = 1+ \frac{T_{wait}}{T_{needService}}
$$

- $T_{wait}$: 等待时间
- $T_{needService}$: 需要服务的时间，也就是执行时间

&emsp;题解：

- T=0 时，A 到达，此时只有 A 且$R_{pA}$最大，执行 A
- T=4 时，B，C，D，E 均已到达，计算$R_p$:
  - $R_{pB} = 1 + \frac{3}{3}$
  - $R_{pC} = 1 + \frac{2}{5}$
  - $R_{pD} = 1 + \frac{1}{2}$
  - $R_{pE} = 1 + \frac{0}{4}$
  - 计算得：$R_{pB}$ > $R*{pD} > $R*{pC} > $R\_{pE}

> 后续各个任务均在同一时间段发生变化，因此这个大小基本不会再变了。

| T        | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
| 高响应比 | A   | A   | A   | A   | B   | B   | B   | D   | D   | C   | C   | C   | C   | C   | E   | E   | E   | E   | Done |

| 进程编号 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| -------- | -------- | -------- | -------- | ------------ |
| A        | 0        | 4        | 4-0=4    | 4/4          |
| B        | 1        | 7        | 7-1=6    | 6/3          |
| C        | 2        | 14       | 14-2 =12 | 12/5         |
| D        | 3        | 9        | 9-3=6    | 6/2          |
| E        | 4        | 18       | 18-4=14  | 14/4         |

平均周转时间：`(4 + 6 + 12 + 6 + 14) / 5 = 8.4`

### 4. 时间片调度算法

&emsp;设一个等待队列`Q`,初始时为空：`Q={A(4)}`, 因为 t=0 时，A 到达。

- t=0 时，从 Q 的队首中取任务 A 执行，时长为一个时间片，执行完毕后，B 到达，B 放入队列中，并且 A 未完成，也放入 Q 中，此时：`Q={B(3),A(3)}`
- t=1 时，取任务 B 执行一个时间片，执行完毕后，C 到达，C 放入队尾，且 B 未完成，也放入队尾，此时：`Q={A(3),C(5),B(2)}`
- t=2 时，取 A 执行一个时间片，执行完毕后，D 到达，D 放入队尾，A 未完成，也放入队尾,此时:`Q={C(5),B(2),D(2),A(2)}`
- t = 3 时，执行 C，E 到达，`Q={B(2),D(2),A(2),E(4),C(4)}`
- t=4 时，执行 B，`Q={D(2),A(2),E(4),C(4)},B(1)`
- t = 5 时，执行 D，`Q={A(2),E(4),C(4),B(1),D(1)}`
- t=6 时，执行 A，`Q={E(4),C(4),B(1),D(1),A(1)}`
- t=7 时,执行 E,`Q={C(4),B(1),D(1),A(1),E(3)}`
- t = 8 时，执行 C，`Q={B(1),D(1),A(1),E(3),C(3)}`
- **t=9 时，执行 B，执行一个时间片后，B 执行完毕**，不需要入队尾,`Q={D(1),A(1),E(3),C(3)}`
- **t=10 时，执行 D，一个时间片后，D 执行完毕**,`Q={A(1),E(3),C(3)}`
- **t=11 时，执行 A，一个时间片后，A 执行完毕**,`Q={E(3),C(3)}`
- t=12 时，执行 E，`Q={C(3),E(2)}`
- t=13 时，执行 C,`Q={E(2),C(2)}`
- t=14 时，执行 E,`Q={C(2),E(1)}`
- t=15 时，执行 C,`Q={E(1),C(1)}`
- **t=16 时，执行 E，一个时间片后，E 执行完毕**,`Q={C(1)}`
- **t=17 时，执行 C，一个时间片后，C 执行完毕**,`Q={}`

| T                    | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9     | 10    | 11    | 12  | 13  | 14  | 15  | 16    | 17    | 18  |
| -------------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ----- | ----- | ----- | --- | --- | --- | --- | ----- | ----- | --- |
| q=1 的时间片调度算法 | A   | B   | A   | C   | B   | D   | A   | E   | C   | **B** | **D** | **A** | E   | C   | E   | C   | **E** | **C** |

| 进程编号 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| -------- | -------- | -------- | -------- | ------------ |
| A        | 0        | 12       | 12-0=12  | 12/4         |
| B        | 1        | 10       | 10-1=9   | 9/3          |
| C        | 2        | 18       | 18-2 =16 | 16/5         |
| D        | 3        | 11       | 11-3=8   | 8/2          |
| E        | 4        | 17       | 17-4=13  | 13/4         |

### 5. 抢占式短作业优先调度

&emsp;修改原题：

| 作业号 | 到达时间 | 运行时间 |
| ------ | -------- | -------- |
| A      | 0        | 4        |
| B      | 1        | 2        |
| C      | 2        | 1        |
| D      | 3        | 3        |
| E      | 4        | 2        |

&emsp;设置任务列表：`L`,初始时为：`L={A(4)}`(t=0 时，A 到达)

- t=0 时，L 中作业 A 执行时间最短，执行 A；
- t=1 时，B 到达，进入任务列表，此时`L={A(3),B(2)}`,取执行时间最短的 B 执行。
- t=2 时，C 到达，进入任务列表，此时`L={A(3),B(1),C(1)}`,取执行时间最短的 B(也可以选 C)执行。
- **t=3 时，B 执行完毕，D 到达**，进入任务列表，此时`L={A(3),D(3),C(1)}`,取 C 执行;
- **t=4 时，C 执行完毕，E 到达**，进入任务列表，此时`L={A(3),D(3),E(2)}`,取 E 执行
- **t=6 时**，E 执行完毕，此时`L={A(3),D(3)}`,取 A 执行
- **t=9 时**，A 执行完毕，此时`L={D(3)}`,取 D 执行
- **t=12 时**，D 执行完毕

> 一般来说，抢占式会引起系统的开销更大。抢占式调度是严格保证任何时刻，让具有最高优先权的进程占有处理剂运行，因此增加了处理机调度的时机，引起为退出处理机的进程进行现场保留，为占有处理机的进程恢复现场等时机开销增大。

## 银行家算法例题一

- 题目：[https://os.mnzdna.xyz/detail/95](https://os.mnzdna.xyz/detail/95)

|     | Allocation  | Max          | Available  |
| --- | ----------- | ------------ | ---------- |
|     | [A, B , C]  | [A, B, C]    | [A ,B ,C ] |
| P0  | [0 , 0 , 3] | [0 , 0 , 4 ] | [1 ,4 ,0 ] |
| P1  | [1 , 0 , 0] | [1 , 7 , 5 ] | [ , , ]    |
| P2  | [1 , 3 , 5] | [2 , 3 , 5 ] | [ , , ]    |
| P3  | [0 , 0 , 2] | [0 , 6 , 4 ] | [ , , ]    |
| P4  | [0 , 0 , 1] | [0 , 6 , 5 ] | [ , , ]    |

- 请问当前系统是否出于安全状态？
- 如果系统中的可利用资源为（0, 6, 2），系统是否安全？如果系统处在安全状态，请给出安全序列；如果系统处在非安全状态，请简要说明原因。

### 判断系统是否处于安全状态

&emsp;判断系统是否处于安全状态本质上就是找到一个安全序列。使用银行家算法求安全序列只需利用下表即可：

| 进程  | Work(Available) |  Need   | Allocation | Work+Allocation |
| :---: | :-------------: | :-----: | :--------: | :-------------: |
| $P_0$ |     [1,4,0]     | [0,0,1] |  [0,0,3]   |     [1,4,3]     |
| $P_2$ |     [1,4,3]     | [1,0,0] |  [1,3,5]   |     [2,7,8]     |
| $P_1$ |     [2,7,8]     | [0,7,5] |  [1,0,0]   |     [3,7,8]     |
| $P_3$ |     [3,7,8]     | [0,6,2] |  [0,0,2]   |    [3,7,10]     |
| $P_4$ |    [3,7,10]     | [0,6,4] |  [0,0,1]   |    [3,7,11]     |

&emsp;其中$Need = Max - Allocation$,看表即可得到安全序列：$P_0,P_2,P_1,P_3,P_4$。

## 银行家算法例题二

- 题目：[https://os.mnzdna.xyz/detail/669](https://os.mnzdna.xyz/detail/669)

试描述避免死锁的银行家算法，若系统运行中出现下述资源分配情况:

| 进程 |  ALLOCATION  |     NEED      |   AVAILABLE   |
| :--: | :----------: | :-----------: | :-----------: |
|      | [A, B, C, D] | [A, B, C, D]  |  [A,B, C, D]  |
|  P0  | [0, 0, 3, 2] | [0, 0, 1, 2]  | [ 1, 6, 2, 2] |
|  P1  | [1, 0, 0, 0] | [1, 7, 5, 0]  |               |
|  P2  | [1, 3, 5, 4] | [2, 3, 5, 6]  |               |
|  P3  | [0, 3,3 ,2]  | [0, 6, 5, 2]  |               |
|  P4  | [0, 0, 1, 4] | [ 0, 6, 5, 6] |               |

- 该系统是否安全？
- 如果进程 P2 此时提出资源申请（1，2，2，2），系统能否将资源分配给它？为什么？

#### 第一问

| 进程  | Work(Available) |     Need      |  Allocation  | Work+Allocation |
| :---: | :-------------: | :-----------: | :----------: | :-------------: |
| $P_0$ |    [1,6,2,2]    |   [0,0,1,2]   |  [0,0,3,2]   |    [1,6,5,4]    |
| $P_3$ |    [1,6,5,4]    |   [0,6,5,2]   |  [0,3,3,2]   |    [1,9,8,6]    |
| $P_1$ |    [1,9,8,6]    |   [1,7,5,0]   |  [1,0,0,0,]  |    [2,9,8,6]    |
| $P_2$ |    [2,9,8,6]    | [2, 3, 5, 6]  | [1, 3, 5, 4] |  [3,12,13,10]   |
| $P_4$ |  [3,12,13,10]   | [ 0, 6, 5, 6] | [0, 0, 1, 4] |  [3,12,14,14]   |

&emsp;可以找到安全序列：$P_0,P_3,P_1,P_2,P_4$

#### 第二问

&emsp;步骤如下：

- 判断$Request[...] <= Need[...]$ ?
- 判断$Request[...] <= Available[...]$ ?
- 请求进程的数据做如下运算：
  - $Available = Avaiable - Request$
  - $Allocation = Allocation + Request$
  - $Need = Need - Reques$
- 再求一遍是否存在安全序列

&emsp;P2 提出资源申请$R(1,2,2,2)$,其中$R(1,2,2,2) <= Need_{p2}(2,3,5,6)$,并且$R(1,2,2,2) <= Available(1,6,2,2)$。然后对 Available,P2 的 Allocation 和 Need 进行运算得到下表：

| 进程 |              ALLOCATION              |                 NEED                 |   AVAILABLE   |
| :--: | :----------------------------------: | :----------------------------------: | :-----------: |
|      |             [A, B, C, D]             |             [A, B, C, D]             |  [A,B, C, D]  |
|  P0  |             [0, 0, 3, 2]             |             [0, 0, 1, 2]             | [ 0, 4, 0, 0] |
|  P1  |             [1, 0, 0, 0]             |             [1, 7, 5, 0]             |               |
|  P2  | [1, 3, 5, 4] + [1,2,2,2] = [2,5,7,6] | [2, 3, 5, 6] - [1,2,2,2] = [1,1,3,6] |               |
|  P3  |             [0, 3,3 ,2]              |             [0, 6, 5, 2]             |               |
|  P4  |             [0, 0, 1, 4]             |            [ 0, 6, 5, 6]             |               |

&emsp;对上表求安全序列，判断是否处于安全状态。在上表中，我们无法得到一个安全序列，因此，不安全，我们不用该将资源分配给它，否则会出现死锁。

## 资源分配问题例题

- 题目：[https://os.mnzdna.xyz/edit/242](https://os.mnzdna.xyz/edit/242)

&emsp;某计算机系统中有 M 个同类型共享资源，有 N 个进程竞争使用，每个进程最多需要 K 个共享资源。该系统不会发生死锁的 K 的最大值是多少？要求给出计算过程，并说明理由。

$$
  核心公式： N * (K - 1) + 1 <= M
$$

&emsp;解析：

$K <= \frac{M}{N} + 1$ 的取整； 说明：出现死锁时占用最多资源的情况是(K-1)N

- 最坏情况假设：当系统濒临死锁时，每个进程都占据了最多的资源,也就是$(K-1)$个;
- 资源剩余：$M-N*(K-1)$
- 避免死锁的条件: **系统剩余的资源必须大于等于每个进程所需的资源数**，$M-N*(K-1) >= K$;
- 变换：$\frac{M-N*(K-1)}{N} >= \frac{K}{N}$ => $\frac{M}{N} - (K-1) >= \frac{K}{N}$ => $\frac{M-K}{N} + 1 >= K$:

$$
  \frac{M}{N} + 1 >= \frac{M-K}{N} + 1 >= K
$$

所以：$K <= \frac{M}{N} + 1$

## 同步与互斥问题

### PV 操作

---

&emsp;**1、桌上有一空盘，最多允许存放一只水果。爸爸可向盘中放一个苹果或放一个桔子，儿子专等吃盘中的桔子，女儿专等吃苹果。试用 P、V 操作实现爸爸、儿子、女儿三个并发进程的同步。**

> 设置三个信号量：S,So,Sa。
>
> - S: 表示可否向盘中放水果，初始值为 1，表示能放水果；
> - So:表示可否取橘子，初始值为 0；
> - Sa: 表示可否取苹果，初始值为 0;

```
Father(){
  while(1){
    P(S);
    // 将水果放入盘中
    if(是橘子){
      V(So);
    }else{
      V(Sa);
    }
  }
}

Son(){
  while(1){
    P(So);
    // 取橘子
    V(S);
    // 吃橘子
  }
}

Daughter() {
  while(1){
    P(Sa);
    // 取苹果
    V(S);
    // 吃苹果
  }
}
```

---

&emsp;**2.有一个仓库，可以存放 A 和 B 两种产品。存储空间充分大，但要求：（1） 每次只能存入一种产品（A 或 B）（2） －N ＜ A 产品数量－B 产品数量＜ M。其中，N 和 M 是正整数。试用 P、V 操作描述产品 A 与 B 的入库过程。**

> 设置互斥信号量：mutex，初始值为 1
> Sa: 表示允许 A 产品比 B 产品多入库的数量，初值为 M-1;即 B 的数量为 0，A 最多为 M-1；
> Sb: 表示允许 B 产品比 A 产品多入库的数量，初始值为 N-1;即 A 的数量为 0,B 最多为 N-1

```
// A产品入库进程
while(1){
  // 生产A产品
  P(Sa);
  P(mutex);
  // A入库
  V(mutex);
  V(sb);
}

// B产品入库进程
while(1){
  // 生产B产品
  P(Sb);
  p(mutex);
  // B入库
  V(mutex);
  V(Sa);
}
```

&emsp;**3、问题描述：假定阅览室最多容纳 100 人阅读，读者进入时，必须在门口的登记表上登记，内容包括：姓名、座号等；离开时要撤销登记内容。用 P、V 操作描述读者进程的同步算法。**

```
define CHAIR 100 // 定义椅子数量
define mutex=1 // 互斥量 可视为锁
define readers=0 // 当前阅览室读者数量

// 读者进程
void readeri(i=1,2,3,...){
  P(mutex); // 获取锁
  if(readers < CHAIR){

    // 读者登记操作
    readers++; // 读者数量+1
    V(mutex); // 释放锁
    // 阅读

    P(mutex); //获取锁，准备离开了
    // 撤销登记
    readers--;
    V(mutex); // 释放锁

  }else{
    V(mutex); // 没椅子就直接释放锁
  }
}

```

&emsp;**4、问题描述：理发店由一个有几张凳子的等待室和一个放有一张理发椅的理发室组成。若没有理发的人员，理发师睡觉；若顾客到来，且所有的椅子占满，则该顾客离开理发店；若理发师正在理发，则该顾客就找一张椅子坐下等待；若理发师在睡觉，则该顾客唤醒理发师。设计一个理发师和顾客的协调程序。**

```
define CHAIR N // 理发店有N把椅子
define mutex=1 // 互斥锁，用于保护对临界资源的访问
define barber_ready=0 // 用于表示理发师是否准备好理发，因为刚开始理发师在睡觉
define customer_ready=0 // 用于表示顾客是否准备好理发
define waiting=0 // 等待的顾客数量

// 理发师进程
void barber(){
  while(1){
    P(customer_ready); // 等待顾客前来理发
    P(mutex); // 获取锁
    waiting--;
    V(barber_ready); // 通知理发师进行理发
    V(mutex);  // 释放锁
    // 理发
  }
}

// 顾客进程
void customer(){
  P(mutex);// 获取锁
  if(waiting < N){
    waiting++; // 等待顾客+1
    V(customer_reader); // 通知有顾客前来理发
    V(mutex); // 释放锁
    P(barber_ready); // 等待理发师
    // 理发

  }else{
    V(mutex);//释放锁
    // 离开
  }
}

```

## 文件系统

### 求 FAT 占用空间

---

&emsp;假定磁盘块的大小为 1KB，对于 540MB 的硬盘，其文件分配表 FAT 需要占用多少存储空间？当硬盘容量为 1.2GB 时，FAT 需要占用多少空间

- 题目:[https://os.mnzdna.xyz/detail/228](https://os.mnzdna.xyz/detail/228)

---

- 当硬盘大小为 540MB 时：

  - 计算盘块：$\frac{540M}{1K} = 540K(个)$
  - 计算表示盘块要用多少字节：$512K < 540K < 1024K$,因此需要用**20 位表示**($1k = 2^{10}$)，也就是**2.5 个字节**.
  - 计算 FAT 要占用的存储空间：$2.5 * 540K = 1350K$

- 当硬盘大小为 1.2G 时：
  - 计算盘块：$\frac{1.2G}{1K} = 1.2M(个)$
  - 计算表示盘块要用多少字节: $1M < 1.2M < 2M$,$2M = 2^{21}$,因此需要用 21 位来表示，**为了方便文件分配表的存取，每个表目用 24 位二进制表示，也就是 3 个字节**。
  - 计算 FAT 要占用的存储空间：$3 * 1.2M = 3.6M$

### 求逻辑地址所对应的物理地址

- 逻辑地址 = 页号 + 页内地址
- 物理地址 = 块号 + 页内地址
- 页号的位数决定页面的多少：页号位 n，则页面的多少为$2^n$字节
- 业内地址的位数决定了页面的大小：业内地址位数为 n,则页面的大小为$2^n$字节

#### 题目一

---

&emsp;某一页表内容自 0 ～ 7 依次为：03,07,0B,11,1A,1D,20,22。请计算页面大小为 1k 和 4k 时的逻辑地址 134D 对应的物理地址。

---

- 页面大小为 1K 时：

  - 使用二进制表示要求的逻辑地址：0001 00**11, 0100, 1101**;
  - 计算业内地址的位数：$1k = 2^{10}$, 也就是 10 位；
  - 计算页号位数：16 - 10 = 6 位；
  - 计算页号：$页号 = 逻辑地址 - 业内地址 = 0001,00 = 4$;
  - 计算块号：页号 4 对应的块号就是：1A = 0001,1010;
  - 计算物理地址：$物理地址 = 块号 + 业内地址 = (01,1010) + (11,0100,1101) = 0110,1011,0100,1101$,16 进制表示：6B4DH.也就是它的物理地址。

- 页面大小为 4k 时：

  - 使用二进制表示要求的逻辑地址：0001 **0011, 0100, 1101**;
  - $4k = 2^{12}$,将逻辑地址从右至左读 12 位，截取左边部分：0001,这部分就是页号，十进制表示为 1
  - 根据页号拿到对应的块号：1 对应的块号就是：07,二进制表示：0000,**0111**,从右至左读 4 位得：0111。
  - 拼接：0111,0011,0100,1101,16 进制表示：734DH.也就是它的物理地址。

  #### 题目二

  ## 内存管理

  ### 分区分配算法

  - 最先适应算法
  - 最优适应算法
  - 最坏适应算法
  - Next 适应算法

  #### 题目一

---

- 题目：[https://os.mnzdna.xyz/edit/184](https://os.mnzdna.xyz/edit/184)

  &emsp;主存有两个空闲区 F1、F2。F1 为 220KB，F2 为 120KB，另外依次有 J1、J2、J3 三个作业请求加载运行，它们的主存需求量分别是 40KB、160KB、100KB，试比较最先适应算法、最优适应算法、Next 适应算法和最坏适应算法的性能。

---

| 分区 |  F1   |  F2   |
| :--: | :---: | :---: |
| 大小 | 220KB | 120KB |

##### 最先适应算法

- 看 J1，需要 40k，分区选择 F1，此时 F1 剩余：220K-40K = 180K;
- 看 J2，需要 160K，分区选择 F1，此时 F1 剩余：180K-160K = 20K；
- 看 J3，需要 100K，分区 F1 无法满足，看 F2，F2 可以满足，选择 F2，此时 F2 剩余：120K-100K=20K；

##### 最优适应算法

- 看 J1，需要 40K，此时分区选择满足需求量的最小值，也就是 F2，此时 F2 剩余：120K - 40K = 80K;
- 看 J2，需要 160K，F1 满足，此时 F1 剩余：220K - 160K = 60K;
- 看 J3，需要 100K，此时 F1，F2 均无法满足；

##### Next 适应算法

- 看 J1，需要 40K，分区选择 F1，此时 F1 剩余：220K - 40K = 180K；
- 看 J2， 需要 160K，分区需要从 F1 的 Next 开始选，也就是 F2，此时 F2 无法满足，再看 F1，F1 满足，此时 F1 剩余：180K-160K=20K;
- 看 J3，需要 100K，分区从 F2 开始选，F2 满足，此时 F2 剩余：120K-100K=20K;

##### 最坏适应算法

- 看 J1，需要 40K，此时分区选择满足需求量的最大值，也就是 F1,此时 F1 剩余：220K-40K=180K;
- 看 J2，需要 160K，选择 F1，此时 F1 剩余：180K-160K=20K;
- 看 J3，需要 100K，选择 F2，此时 F2 剩余：120K - 100K = 20K

### 页面置换算法

#### 例题一

&emsp;在一个请求分页系统中，有一个长度为 5 页的进程，假如系统为它分配 3 个物理块，并且此进程的页面走向为**2，3，2，1，5，2，4，5，3，2，5，2**。分别用 FIFO，LRU，OPT 算法分别计算出程序访问过程中所发生的缺页次数。

##### FIFO

| FIFO     | 2   | 3   | 2   | 1   | 5   | 2   | 4   | 5   | 3   | 2   | 5   | 2   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理块 1 | 2   | 2   | 2   | 2   | 5   | 5   | 5   | 5   | 3   | 3   | 3   | 3   |
| 物理块 2 |     | 3   | 3   | 3   | 3   | 2   | 2   | 2   | 2   | 2   | 5   | 5   |
| 物理块 3 |     |     |     | 1   | 1   | 1   | 4   | 4   | 4   | 4   | 4   | 2   |
| 是否缺页 | Y   | Y   | N   | Y   | Y   | Y   | Y   | N   | Y   | N   | Y   | Y   |

- 缺页次数：9，缺页率：9/12 = 3/4

##### LRU

| LRU      | 2   | 3   | 2   | 1   | 5   | 2   | 4   | 5   | 3   | 2   | 5   | 2   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理块 1 | 2   | 2   | 2   | 2   | 2   | 2   | 2   | 2   | 3   | 3   | 3   | 3   |
| 物理块 2 |     | 3   | 3   | 3   | 5   | 5   | 5   | 5   | 5   | 5   | 5   | 5   |
| 物理块 3 |     |     |     | 1   | 1   | 1   | 4   | 4   | 4   | 2   | 2   | 2   |
| 是否缺页 | Y   | Y   | N   | Y   | Y   | N   | Y   | N   | Y   | Y   | N   | N   |

- 缺页次数：7，缺页率：7/12

##### OPT

| OPT      | 2   | 3   | 2   | 1   | 5   | 2   | 4   | 5   | 3   | 2   | 5   | 2   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理块 1 | 2   | 2   | 2   | 2   | 2   | 2   | 4   | 4   | 4   | 2   | 2   | 2   |
| 物理块 2 |     | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   |
| 物理块 3 |     |     |     | 1   | 5   | 5   | 5   | 5   | 5   | 5   | 5   | 5   |
| 是否缺页 | Y   | Y   | N   | Y   | Y   | N   | Y   | N   | N   | Y   | N   | N   |

- 缺页次数：6，缺页率：6/12=1/2

#### 例题二

---

题库：[https://os.mnzdna.xyz/detail/679](https://os.mnzdna.xyz/detail/679)

&emsp;在一个请求分页系统中，分别采用 FIFO 和 LRU 页面置换算法时，假如一个作业的页面访问顺序为 4，3，2，1，4，3，5，4，3，2，1，5，当分配给该作业的物理块数 M 为 4 时，试试写出页面访问的过程，并计算访问中所发生的缺页次数和缺页率？

---

##### FIFO

| FIFO     | 4   | 3   | 2   | 1   | 4   | 3   | 5   | 4   | 3   | 2   | 1   | 5   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理块 1 | 4   | 4   | 4   | 4   | 4   | 4   | 5   | 5   | 5   | 5   | 1   | 1   |
| 物理块 2 |     | 3   | 3   | 3   | 3   | 3   | 3   | 4   | 4   | 4   | 4   | 5   |
| 物理块 3 |     |     | 2   | 2   | 2   | 2   | 2   | 2   | 3   | 3   | 3   | 3   |
| 物理块 4 |     |     |     | 1   | 1   | 1   | 1   | 1   | 1   | 2   | 2   | 2   |
| 是否缺页 | Y   | Y   | Y   | Y   | N   | N   | Y   | Y   | Y   | Y   | Y   | Y   |

- 缺页次数：10，缺页率：10/12 = 5/6

##### LRU

| FIFO     | 4   | 3   | 2   | 1   | 4   | 3   | 5   | 4   | 3   | 2   | 1   | 5   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理块 1 | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   |
| 物理块 2 |     | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 2   | 2   | 2   |
| 物理块 3 |     |     | 2   | 2   | 2   | 2   | 5   | 5   | 5   | 5   | 5   | 5   |
| 物理块 4 |     |     |     | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 是否缺页 | Y   | Y   | Y   | Y   | N   | N   | Y   | N   | N   | Y   | N   | N   |

- 缺页次数：6，缺页率：6/12=1/2

### 磁盘调度算法

#### 例题一

&emsp;某磁盘有 8192 个磁道，编号为 0 ～ 8191，在完成了磁道 1250 处的请求后，当前正在磁道 3500 处为一个请求服务。若此时请求队列的先后顺序为 1000，4000，3300，5600，1300，6000，1200，2500。回答下述问题：

（1）采用 FCFS 算法完成上述请求。请写出磁头移动的顺序，并计算平均寻道长度；
（2）采用 SSTF 算法完成上述请求。请写出磁头移动的顺序，并计算平均寻道长度；
（3）采用 SCAN 算法完成上述请求。请写出磁头移动的顺序，并计算平均寻道长度；

##### FCFS

&emsp;磁盘移动顺序,**按顺序访问**：

- 3500 -> 1000 -> 4000 -> 3300 -> 5600 -> 1300 -> 6000 -> 1200 -> 2500

&emsp;平均寻道长度：

$$
\frac{(|3500-1000| + |1000-4000| + |4000-3300| + |3300-5600| + |5600-1300| + |1300-6000| + |6000-1200| + |1200-2500|)}{8}
$$

##### SSTF

&emsp;**哪个进程的寻道位置与当前位置最近，先为该进程服务**：

- 3500 -> 3300 -> 2500 -> 1300 -> 1200 -> 1000 -> 4000 -> 5600 -> 6000

##### SCAN

&emsp;**模仿电梯动作规律，由于磁头从 1250 到达 3500，因此先向大磁道号方向处理，再向小磁道号方向处理**；

排序：1000,1200,1300,2500,3300,`*`3500`*`,4000,5600,6000

- 3500 -> 4000 -> 5600 -> 6000 -> 3300 -> 2500 -> 1300 -> 1200 -> 1000

假设 n 为每个进程所需要的资源数，m 为进程数，A 为系统的资源数，则满足(n - 1) \* m >= A 的最小整数 m 即为可能产生死锁的最小进程数。该公式同样可以用于求每个进程需要多少资源时可能会产生死锁。
