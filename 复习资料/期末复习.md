# 操作系统期末复习

## 第一章 操作系统引论

### 1. 什么是操作系统

&emsp;操作系统为用户完成所有"硬件相关、应用无关"的工作，以给用户方便、高效、安全的使用环境。

#### 1.1 定义

&emsp;操作系统是一个大型的程序系统，它负责计算机的全部软、硬件资源的分配、调度工作，控制并协调多个任务的活动，实现信息的存取和保护。它提供用户接口，使用户获得良好的工作环境。

#### 1.2 目标

- 方便性：配置 OS 后计算机系统更容易使用；
- 有效性：改善资源利用率；提高系统吞吐量；
- 可扩充性：OS 的结构（无结构发展 -> 模块化结构 -> 层次化结构 -> 微内核结构）
- 开放性：OS 遵循世界标准范围。

#### 1.3 作用

- OS 作为用户与计算机硬件系统之间的接口。**OS 处于用户与计算机硬件系统之间，用户通过 OS 来使用计算机系统**。
- OS 是计算机系统资源的管理者。
  - 处理机管理是用于分配和控制处理机；
  - 存储器管理是负责内存的分配与回收；
  - IO 设备管理是负责 IO 设备的分配与操作；
  - 文件管理是用于实现文件的存取、共享和保护；
- OS 实现了对计算机资源的抽象

### 2. 操作系统的发展过程

#### 2.1 手工操作阶段

&emsp;人工操作方式：用户独占全机，资源空闲浪费。

- 手工装卸、人工判断、手工修改与调试内存指令等造成 CPU 空闲；
- 提前完成造成剩余预约时间内的 CPU 完全空闲；
- IO 设备的慢速与 CPU 的速度不匹配造成的 CPU 空闲等待时机；

#### 2.2 单道批处理系统

&emsp;单道批处理系统是在解决人机矛盾和 CPU 与 IO 设备速度不匹配矛盾的过程中形成的。批处理系统旨在提高系统资源的利用率和系统的吞吐量。

&emsp;缺点：**系统资源利用率低**

&emsp;特征：

- 自动性：一批作业自动依次运行，无需人工干预；
- 顺序性：各道作业是顺序进入内存；
- 单道性：内存中任意时刻只有一道作业；

#### 2.3 多道批处理系统

&emsp;为了进一步提高资源利用率和系统吞吐量。在该系统中，用户提交的作业都先存在外存中，在作业 A 在执行 IO 请求时，CPU 空闲，此时调度作业 B，防止 CPU 空闲。同理按一定的算法调用作业，防止 CPU 空闲。

> 推动多道批处理系统形成和发展的动力是提高资源利用率和系统吞吐量。

&emsp;优点：

- 资源利用率高；
- 系统吞吐量大；

&emsp;缺点：

- 平均周转时间长；
- 无交互能力；

&emsp;特点：

- 多道：内存同时存在多个作业；
- 宏观上并行：同时有多道程序在内存中运行；
- 微观上串行：任意时刻最多只有一道作业占用 CPU，多道程序交替使用 CPU

#### 2.4 分时系统

&emsp;分时系统是指在一台主机上连接多个带有显示器和键盘的终端，同时允许多个用户通过自己的键盘，以交互的方式使用计算机，共享主机中的资源。

&emsp;特征：

- 多路性：允许同一主机联接多台终端；
- 独立性：每一用户独占一个终端；每个用户感觉不到其它用户的存在；
- 及时性：用户请求能及时响应；
- 交互性：可进行广泛的人机对话

#### 2.5 实时操作系统

&emsp;实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。

&emsp;特征：

- 多路性：对实时处理系统，系统按分时原则为多个终端服务；对实时控制系统，系统经常对多路现场信息进行采集；以及对多个对象或多个执行机构进行控制；
- 独立性：实时处理下系统，每个终端用户向实时系统提出服务请求时，彼此独立；实时控制系统对信息的采集和对对象的控制彼此不干扰；
- 及时性：开始截止时间/完成截止时间；
- 交互性：仅限于访问专用服务程序；
- 可靠性：多级容错措施保障系统和数据安全；

#### 2.6 微机操作系统

#### 2.7 多处理机操作系统

#### 2.8 网络操作系统

#### 2.9 分布式操作系统

#### 2.10 嵌入式操作系统

### 3. 操作系统的基本特征

#### 3.1 并发

&emsp;并发是指在内存中放多道作业，在一个时间段上看，每一道作业能不同程度地向前推进。但在任何一个时间点上只能有一道占用 CPU。

- 串行：在内存中每次只能放一道作业，只有它完全执行完后别的作业才能进入内存执行；
- 并行：存在于有多个 CPU 的环境中，在内存中放多道作业，在任意时间点上都可能有多道作业在不同的 CPU 上同时执行；

#### 3.2 共享

&emsp;系统中的资源可供多个并发的进程共同使用。根据资源属性的不同，有两种资源共享方式：**互斥共享方式**和**同时访问方式**。

#### 3.3 虚拟

&emsp;通过某种技术将一个物理实体映射为若干个逻辑上对应物，或将多个物理实体映射为一个逻辑实体。

&emsp;虚拟是操作系统管理系统资源的重要手段，可提高资源利用率。

#### 3.4 异步

&emsp;不确定性：什么时候开始，执行多久时间，终止时间。

### 4.操作系统的主要功能

- **处理机管理功能**：进程控制、进程同步、进程通信、调度；
- **存储器管理功能**：内存分配、内存保护、存储扩充、地址映射；
- **设备管理功能**：缓冲管理、设备分配、设备处理；
- **文件管理功能**：文件存储空间的管理、目录管理、文件的读/写管理和保护；
- 操作系统与用户之间的接口：命令接口、程序接口、图形接口；
- 现代 OS 的新功能：系统安全、支持多媒体、网络通信等。

### 5. 操作系统的结构设计

&emsp;传统 OS 结构:无结构 OS、模块化 OS、分层式 OS；
&emsp;现代 OS 结构：微内核结构；

## 第二章 进程的描述与控制

### 1. 进程的定义和特征

&emsp;进程有各式各样的定义：

- 行为的一个规则叫做程序，程序在处理机上执行时所发生的活动称为进程。
- 具有一定功能的程序在某个数据集合上的一次活动。
- 进程是一个程序与其数据一道通过处理机的执行所发生的活动。
- 进程是指进程实体的运行过程，是系统进行资源分配和调度的独立单位。
- 程序的执行过程，从开始到 结束

&emsp;进程的特征：

- 结构性：由程序、数据、控制块三部分组成；
- 动态性：进程是程序的执行过程；
- 并发性：多个进程可同存于内存中，能在一段时间内同时运行；
- 独立性：独立运行的基本单位，独立获得资源和调度的基本单位；
- 异步性：各进程按各自独立的不可预知的速度向前推进；

### 2. 进程与程序的区别：

- 程序是指令的有序集合，与其本身没有任何运行含义，是一个静态概念。
- 进程是程序在处理机上的一次执行过程，它是一个动态的概念。
- 进程更能真实地描述并发，而程序不能；
- 进程是由程序、数据和进程控制块三部分组成的；
- 同一程序同时运行于若干数据集合上，它将属于若干个不同的进程。也就是说，一个程序可以对应多个进程。

### 3. 进程的 3 种状态及转换

- 就绪状态（R 态）：**存在于处理机调度队列中的所有进程，它们已经准备就绪，一旦得到 CPU，就立即可以运行**。
- 运行状态（E 态）：正在运行的进程所处的状态为运行状态。
- 等待/阻塞/睡眠状态（B 态）：若一个进程正在等待某一事件发生，这时即使给它 CPU，它也无法运行，该进程状态就处于等待状态。

![alt text](images/2.1.png)

&emsp;状态进程模型：

![alt text](images/2.2.png)

### 4. 进程控制块 PCB

&emsp;PCB 是 OS 中最重要的记录型数据结构：

- PCB 是 OS 感知进程存在的唯一标志；
- 进程与 PCB 是一一对应的；
- PCB 随进程创建而建立，随进程结束而回收；
- PCB 应常驻内存；

> PCB 的作用是：**将一个不能独立运行的程序变成一个可以独立运行的基本单位，一个能与其它进程并发执行的进程**。

&emsp;进程描述信息：

- 进程标识符：唯一，通常是一个整数；
- 进程名：基于可执行文件名；
- 用户标识符：进程组关系；

### 5. 进程同步

#### 5.1 制约关系

- 间接相互制约关系：系统资源竞争，进程间彼此无关；
- 直接相互制约关系：进程间合作，彼此相关；

#### 5.2 临界资源

&emsp;一次仅允许一个进程访问的资源。

#### 5.3 临界区

&emsp;临界段，在每个程序中，访问临界资源的那段程序。

> &emsp;程序段 A、B 有关于变量 X 的临界区，而 C、D 有关于变量 Y 的临界区，那么 A、B 之间需要互斥执行，C、D 之间也需要互斥执行，但 A 与 C、B 与 D 之间不需要互斥执行。
> **&emsp;临界区是对某一临界资源而言的，对于不同临界资源的临界区，它们之间不存在互斥。**

#### 5.4 同步机制应遵循的规则

- 空闲让进；
- 忙则等待；
- 有限等待；
- 让权等待；

#### 5.5 信号量机制

- 整型信号量：定义一个整型量，由两个标准原子操作 wait(S)(即：P 操作)和 signal(S)(即：V 操作)来访问。两个操作均为原语操作。

##### 例题

---

&emsp;**1、桌上有一空盘，最多允许存放一只水果。爸爸可向盘中放一个苹果或放一个桔子，儿子专等吃盘中的桔子，女儿专等吃苹果。试用 P、V 操作实现爸爸、儿子、女儿三个并发进程的同步。**

> 设置三个信号量：S,So,Sa。
>
> - S: 表示可否向盘中放水果，初始值为 1，表示能放水果；
> - So:表示可否取橘子，初始值为 0；
> - Sa: 表示可否取苹果，初始值为 0;

```
Father(){
  while(1){
    P(S);
    // 将水果放入盘中
    if(是橘子){
      V(So);
    }else{
      V(Sa);
    }
  }
}

Son(){
  while(1){
    P(So);
    // 取橘子
    V(S);
    // 吃橘子
  }
}

Daughter() {
  while(1){
    P(Sa);
    // 取苹果
    V(S);
    // 吃苹果
  }
}
```

---

&emsp;**2.有一个仓库，可以存放 A 和 B 两种产品。存储空间充分大，但要求：（1） 每次只能存入一种产品（A 或 B）（2） －N ＜ A 产品数量－B 产品数量＜ M。其中，N 和 M 是正整数。试用 P、V 操作描述产品 A 与 B 的入库过程。**

> 设置互斥信号量：mutex，初始值为 1
> Sa: 表示允许 A 产品比 B 产品多入库的数量，初值为 M-1;即 B 的数量为 0，A 最多为 M-1；
> Sb: 表示允许 B 产品比 A 产品多入库的数量，初始值为 N-1;即 A 的数量为 0,B 最多为 N-1

```
// A产品入库进程
while(1){
  // 生产A产品
  P(Sa);
  P(mutex);
  // A入库
  V(mutex);
  V(sb);
}

// B产品入库进程
while(1){
  // 生产B产品
  P(Sb);
  p(mutex);
  // B入库
  V(mutex);
  V(Sa);
}
```

&emsp;**3、问题描述：假定阅览室最多容纳 100 人阅读，读者进入时，必须在门口的登记表上登记，内容包括：姓名、座号等；离开时要撤销登记内容。用 P、V 操作描述读者进程的同步算法。**

```
define CHAIR 100 // 定义椅子数量
define mutex=1 // 互斥量 可视为锁
define readers=0 // 当前阅览室读者数量

// 读者进程
void readeri(i=1,2,3,...){
  P(mutex); // 获取锁
  if(readers < CHAIR){

    // 读者登记操作
    readers++; // 读者数量+1
    V(mutex); // 释放锁
    // 阅读

    P(mutex); //获取锁，准备离开了
    // 撤销登记
    readers--;
    V(mutex); // 释放锁

  }else{
    V(mutex); // 没椅子就直接释放锁
  }
}

```

&emsp;**4、问题描述：理发店由一个有几张凳子的等待室和一个放有一张理发椅的理发室组成。若没有理发的人员，理发师睡觉；若顾客到来，且所有的椅子占满，则该顾客离开理发店；若理发师正在理发，则该顾客就找一张椅子坐下等待；若理发师在睡觉，则该顾客唤醒理发师。设计一个理发师和顾客的协调程序。**

```
define CHAIR N // 理发店有N把椅子
define mutex=1 // 互斥锁，用于保护对临界资源的访问
define barber_ready=0 // 用于表示理发师是否准备好理发，因为刚开始理发师在睡觉
define customer_ready=0 // 用于表示顾客是否准备好理发
define waiting=0 // 等待的顾客数量

// 理发师进程
void barber(){
  while(1){
    P(customer_ready); // 等待顾客前来理发
    P(mutex); // 获取锁
    waiting--;
    V(barber_ready); // 通知理发师进行理发
    V(mutex);  // 释放锁
    // 理发
  }
}

// 顾客进程
void customer(){
  P(mutex);// 获取锁
  if(waiting < N){
    waiting++; // 等待顾客+1
    V(customer_reader); // 通知有顾客前来理发
    V(mutex); // 释放锁
    P(barber_ready); // 等待理发师
    // 理发

  }else{
    V(mutex);//释放锁
    // 离开
  }
}

```

### 6. 进程通信

| 方式     | 传输的信息量       | 使用场景       | 关键词                                                                 |
| -------- | ------------------ | -------------- | ---------------------------------------------------------------------- |
| 信号     | 少量               | 任何           | 硬件来源、软件来源 / 信号队列                                          |
| 管道     | 大量               | 亲缘进程间     | 单向流动 / 内核缓冲区 / 循环队列 / 没有格式的字节流 / 操作系统负责同步 |
| 命名管道 | 大量               | 任何           | 磁盘文件 / 访问权限 / 无数据块 / 内核缓冲区 / 操作系统负责同步         |
| 信号量   | N                  | 任何           | 互斥同步 / 原子性 / P 减 V 增                                          |
| 共享内存 | 大量               | 多个进程       | 内存映射 / 简单快速 / 操作系统不保证同步                               |
| 消息队列 | 比信号多，但有限制 | 任何           | 有格式 / 按消息类型过滤 / 操作系统负责同步                             |
| 套接字   | 大量               | 不同主机的进程 | 读缓存区 / 写缓冲区 / 操作系统负责同步                                 |

### 7. 线程

&emsp;线程是**进程中的一个实体，是被系统独立调度的基本单位**。

#### 7.1 线程的引入

- 引入进程的目的：多个程序更好地并发执行，改善资源利用率、提高系统效率；
- 引入线程的目的：减少并发执行时所付出的时空开销，使并发细粒度更细、并发性更好。

#### 7.2 进程的两个基本属性

- 进程是一个资源分配的基本单位；
- 进程是一个可独立调度和分派的基本单位；

#### 7.3 引入线程的好处

- 创建一个新线程花费时间少；
- 线程的终止时间比进程短；
- 同进程内的线程切换时间比进程短；
- 同一进程内的线程之间相互可以通信而无需调用内核；

## 第三章 处理机调度与死锁

### 1. 处理机调度的三个层次

- 高级调度：决定外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，再将新创建的进程排在就绪队列上，准备执行。
- 中级调度：涉及进程在内、外存间的交换，从存储器资源管理的角度来看，把进程的部分或全部换出到外存上，可为当前运行进程的执行提供所需内存空间。
- 低级调度：用来决定就绪队列中哪个进程应获得处理机，再由分派程序执行把处理机分配给进程。

&emsp;进程调度的两种方式：

- 非抢占式：不允许某进程抢占已分配出去的处理机；
- 抢占式：允许调度程序根据某种规则，暂停正在执行的进程，将处理机重新分配给另一进程。抢占原则有：**优先权原则、短作业优先原则、时间片原则**。

### 2. 调度算法

&emsp;根据系统的资源分配策略所规定的资源分配算法。

&emsp;`提交时间Si，运行结束时间Ei,则周转时间: Ti=Ei-Si,平均周转时间T=(1/n)*Sum(Ti),i=1,2,3,...,n;平均带权周转时间W=(1/n)*Sum(Ti/Ts),i=1,2,...,n,其中Ts为服务时间`;

#### 2.1 先来先服务调度算法(FCFS)

&emsp;作业调度：完成选择一个或多个最先进入后备队列的作业，将它们调入内存，为它们分配资源、创建进程，并放入就绪队列中。
&emsp;进程调度：按照进程就绪的先后次序来调度进程，为之分配处理机。

![alt text](images/3.1.png)

#### 2.2 短作业优先调度算法(SJF)

&emsp;SJF 是一种基于作业长度的调度算法。在这种算法中，优先选择执行所需时间最短的作业。SJF 可分为抢占式和非抢占式。

- 非抢占式：**按照先后到达顺序和执行时间进行调度**，一旦作业开始执行，就不会被中断，直到完成。
- 抢占式：**如果有一个新的作业到达且剩余时间比当前正在执行的作业的剩余时间短，则当前作业会被中断，新的作业会被执行。**

![alt text](images/3.2.png)

### 3. 死锁

&emsp;**一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到该资源，这种现象称为进程死锁(Deadlock)，这一组进程就称为死锁进程**。

#### 3.1 死锁原因

- 竞争资源引起进程死锁；
- 进程推进顺序不当引起死锁；

#### 3.2 死锁的四个必要条件

- 互斥条件：设计的资源是非共享的；
- 不可抢占条件：不能强行剥夺进程拥有的资源；
- 请求和保持条件： 进程在等待一新资源时继续占有已分配的资源；
- 环路条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被下一个进程所请求。

#### 3.3、处理死锁的方法

- 预防死锁：通过设置某些限制条件，去破坏死锁四个必要条件中的一个或多个，来防止死锁。
- 避免死锁：不事先设置限制条件去破坏产生死锁的条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。
- 检测死锁：允许死锁发生，但可通过检测机构及时检测出死锁的发生，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁清除掉。
- 解除死锁：与检测死锁相配套，用于将进程从死锁状态解脱出来。常用的方法是撤消或挂起一些进程。以回收一些资源，再将它们分配给处于阻塞状态的进程，使之转为就绪状态

#### 3.4 避免死锁 - 银行家算法

- 可利用资源向量 Available。它是一个含有 m 个元素的数组，其中每个元素代表一类 可利用资源的数目。
- 最大需求矩阵 Max。n\*m 矩阵，表示 n 个进程的每一个对 m 类资源的最大需求。
- 分配矩阵 Allocation 。n\*m 矩阵，表示每个进程已分配的每类资源的数目。
- 需求矩阵 Need 。n\*m 矩阵，表示每个进程还需要各类资源数。

&emsp;步骤如下：

![alt text](images/3.3.png)

&emsp;例题如下：

&emsp;ABCD 四种资源，P0~P3 四个进程。P0 的 Allocation(0 0 3 2)表示 系统已经为 P0 进程分配 ABCD 四种资源分别为：0 0 3 2.

![alt text](images/3.4.png)

(1)该状态是否安全？

解：

&emsp;利用安全性算法进行分析可得下表：

![alt text](images/3.5.png)

由此可以找到安全序列：{P0,P3,P4,P1,P2}。

> 看 P0，因为：Work > Need, 说明当前剩余资源可以满足 P0 进程执行，因此当 P0 执行完毕后,P0 进程之前分配到的 ABCD 资源将还给系统，因此下一次可分配的资源为：Work+Allocation。依次类推。只要能找到一个顺序让 P0 ～ P4 进程都能执行完毕，则说明状态是安全的，而这个顺序就是安全序列。

(2)若进程 P2 提出请求 Request（1，2，2，2）后，系统能否将资源分配给它？

解：

①Request2(1,2,2,2)<=Need2(2,3,5,6)
②Request2(1,2,2,2)<=Available(1,6,2,2)
③ 系统先假定可为 P2 分配资源，并修改 Available，Allocation2 和 Need2 向量：
Available=(0,4,0,0)
Allocation2=(2,5,7,6)
Need2=(1,1,3,4)
此时再进行安全性检查，发现 Available=(0,4,0,0) 不能满足任何一个进程，所以判定系统进入不安全状态，即不能分配给 P2 相应的 Request(1,2,2,2)。

## 第四章 存储器管理

### 1. 存储器的层次结构

![alt text](images/4.1.png)

### 2. 存储器管理的空间分配方式

- 连续分配：单一连续分配、固定分区分配、动态连续分配；
- 离散分配：分页存储管理、分段存储管理。

### 3. 连续分配存储管理方式

#### 3.1 程序的装入和链接

&emsp;**链接：**

- **静态链接方式**：程序运行以前，将各个目标模块及它们所需要的库函数，链接成一个完整的装入模块，又可称为可执行文件，通常不再拆开。
- **装入时动态链接**：用户源程序经编译后所得的目标模块，在装入内存时，边装入边链接，即在装入一个目标模块时，如果发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，进行链接。
- **运行时动态链接**：这种链接方式是将对某些模块的链接推迟到执行时才进行。在执行过程中，当发现一个被调用模块尚未调入内存时，立即由操作系统去找到该模块并装入内存，再把它链接到调用者模块上。

&emsp;**装入：**

- **绝对装入方式**：逻辑地址转换成物理地址的过程发生在程序编译或汇编时；
- **可重定位装入方式（静态重定位）**：逻辑地址转换成物理地址的过程发生在程序装入到内存时进行；
- **动态运行时装入方式（动态重定位）**：逻辑地址转换为物理地址的过程推迟到程序真正执行时。

#### 3.2 连续分配方式

- **单一连续分配**：最简单，适用于单用户、单任务的 OS。
  - 优点：易于管理；
  - 缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存；
- **固定分区分配**：把内存划分为个数固定、大小相等或不等的多个区域。分区的划分由计算机操作员或操作系统给出，并给出分区说明表。
  - 优点：易于实现，开销小；
  - 缺点：内存碎片造成浪费、分区总数固定，限制了并发执行的程序数目；可以和覆盖、交换技术配合使用。
- **动态分区分配**：指在系统运行的过程中建立分区，并使分区的大小刚好与作业的大小相等。**这种存储管理的方法解决了固定分区严重浪费内存的问题，是一种较为实用的存储管理方法。**

#### 3.2 动态分区分配算法

- **首次适应算法（FF，first fit）**：FF 要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，会优先从内存中的低地址进行查找分配。
- **循环首次适应算法（NF，next fit）**：NF 由 FF 演变，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。
- **最佳适应算法啊（BF，best fit）**：每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。
- **最坏适应分配算法（worst fit）**：扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用分区的分配与回收。
- **快速适应算法(quick fit)**：该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类。

&emsp;例题：`某基于动态分区存储管理的计算机，其主存容量为55MB（初始为空闲），采用最佳适配算法，分配和释放的顺序为：分配15MB，分配30MB，释放15MB，分配8MB，分配6MB，此时主存中最大空闲分区的大小是多少？`

> 最佳适配算法是指每次为作业分配内存空间时，总是找到能满足空间大小需要的最小的空闲分区给作业，可以产生最小的内存空闲分区.

![](images/4.2.png)

&emsp;如上图所示，**最大空闲分区的大小为 9MB**。

### 4. 离散分配管理方式

#### 4.1 分页存储管理方式

&emsp;将程序的逻辑地址空间和存储空间按相同长度为单位进行划分。每个程序逻辑空间分成一些大小相同的片段，叫做页面或页。**把内存的存储空间也分成相同的片段，叫做物理块或页框**。分配的物理块可以连续也可以不连续。

![alt text](images/4.3.png)

&emsp;**页表**：

- 页表的作用是**实现从页号到物理块号的映射**；
- 系统在内存空间设置一片区域作为页表区，系统为每个进程提供一个页表。进程页表的起始地址放在进程的 PCB(进程控制块)中。
- 页表包含以下几个表项：
  - 页号：登记程序地址空间的页号；
  - 块号：登记相应的页所对应的内存块号；
  - 其它：登记与存储信息保护有关的信息；

![alt text](images/4.4.png)

&emsp;例如：

- 作业 1 有 2 页分别装入内存的第 5、6 块；
- 作业 2 有 3 页分别装入内存的第 2、4、7 块；
- 作业 3 有 1 页装入内存的第 8 块；

![alt text](images/4.5.png)

#### 4.2 有关页表的计算题

&emsp;若给出的程序地址为 10 进制，则用公式：

$$
  程序地址 / 页长
$$

- 得到的**商为页号**；
- 得到的**余数为块号（页内地址）**；

&emsp;例如：程序地址为 8457，页长为 4KB，则：

- 页号：8457 / (4 \* 1024) = 2
- 块号（页内地址）：8457 mod (4 \* 1024) = 256

#### 4.2 分段存储管理方式

&emsp;**分段存储管理方式的引入**

- 通常，程序都可以分为若干个段，每个段大多都是一个相对独立的逻辑单位；
- 实现和满足嘻嘻共享，信息保护，动态链接以及信息的动态增长等需求，也都是以段为基本单位的。

&emsp;**基本原理**

- 分段
  - 作业的地址空间被划分为若干段，每个段定义了一组逻辑信息。例如主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等，通常，用段号代替段名。**每个段都从 0 开始编址，并采用一段连续的地址空间。**
  - **段的长度由相应的逻辑信息组的长度决定，因此各段的长度并不相等**。

![alt text](images/4.6.png)

- 段表

  - 类似与分页系统，分段系统中**段也是离散的分布在内存**中，所以也需要为每个进程建立一个段映射表，简称段表。
  - 每个段在表中占有一个表项，其中记录了该段在内存空间的起始地址（基址）和段的长度。

  ![alt text](images/4.7.png)

&emsp;**地址变化机构**

- 为了实现进程**从逻辑地址到物理地址**的变换功能，在系统中设置了**段表寄存器**，用于**存放段表始址和段表长度 TL**。
- 在进行地址变换时:
  - 系统将逻辑地址中的段号与段表长度 TL 进行比较。若 S>TL，表示段号太大，是访问越界，于是产生越界中断信号。
  - 若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的起始地址。
  - 再检查段内地址 d 是否超过该段的段长 SL。若超过，即 d>SL，同样发出越界中断信号。
  - 若未越界，则将该段的基址 d 与段内地址相加，即可得到要访问的内存物理地址。

![alt text](images/4.8.png)

&emsp;**分页和分段的区别**

|              |       分段       |          分页          |
| :----------: | :--------------: | :--------------------: |
|   信息单位   |  信息的逻辑单位  |     信息的物理单位     |
|     大小     |       不定       |          固定          |
|    可见性    | 程序员确定，可见 | 系统确定，程序员不可见 |
|   地址空间   |   二维地址空间   |    一维线性地址空间    |
| 信息共享保护 |       方便       |         不方便         |

#### 4.3 段页式存储管理方式

&emsp;分页系统以页面作为内存分配的基本单位，能够有效提高内存的利用率，而分段系统以段作为内存分配的基本单位，它能够更好的满足用户多方面的需求。而段页式系统这很好的集两者之长。**段页式系统既有分段系统的便于实现、分段可共享、已与保护、可动态链接等一系列优点；又能像分页系统那样，很好的解决内存的外部碎片问题**。

&emsp;**基本原理**

- 段页式系统的基本原理是分段和分页原理的结合，即**先将用户程序段分为若干段，再把系统分为若干页，为每个段分配一个段名**。
- 段页地址结构包括三部分：段号、段内页号、页内地址(块号)

![alt text](images/4.10.png)

&emsp;**段页式管理的地址映射**

- 先通过段号在段表中进行查找，找到对应页表的内存地址;
- 再通过页号在页表中进行查找，找到页框号（20 位）;
- 再将页框号和页内地址合并为物理地址;

## 第五章 虚拟存储器

### 1. 概念

&emsp;虚拟存储器就是使用虚拟技术从逻辑上对存储器进行扩充。

### 2. 虚拟存储器的特征

- **多次性**：可以把一个程序分多次装入内存，每次装入当前运行需要使用的部分；
- **交换性（或非驻留性）**：在程序执行过程中，可以把当前暂不使用的部分换出内存，若以后需要时再换进内存；
- **离散性**：程序在内存中可分段存放，每一段是连续的—；
- **虚拟性**：虚拟存储器还有一个最重要的特征虚拟性。从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。

### 3. 虚拟存储器的定义

&emsp;所谓虚拟存储器，是指**仅把程序的一部分装入内存便可运行程序的存储器系统**。具体地说，所谓虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。

&emsp;虚拟存储器并非可以无限大，其容量受外存大小和指令中地址长度两方面的限制。

### 4. 分页虚拟存储管理方式

#### 4.1 基本原理

&emsp;分页虚拟存储管理方式是在分页系统的基础上，增加了请求调页功能、页面置换功能所形成的虚拟存储器系统。
&emsp;在分页虚拟存储管理时使用的页表，是在原来页表的基础上发展起来的，包括以下内容：物理块号、状态位、访问位、修改位、外存地址 。

![alt text](images/5.1.png)

#### 4.2 缺页中断

&emsp;每当要访问的页面不在内存时，便产生一缺页中断，请求操作系统把所缺页面调入内存。，请求操作系统把所缺页面调入内存。缺页中断作为中断，它同样需要经历诸如保护 CPU 现场环境、分析中断原因、转入缺页中断处理程序进行处理、恢复 CPU 环境等几个步骤。

#### 4.3 内存分配策略

&emsp;概念：

- 最小物理块数
  - 指能保证进程正常运行所需的最少物理块数
  - 进程所需的最少物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。
- 工作集
  - 指驻留在物理内存中的虚拟页面的子集
  - 进程开始执行后，随着访问新页面逐步建立较稳定的工作集。当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。

&emsp;初始分配策略：

- 平均分配；
- 按比例分配；
- 加权分配；

&emsp;运行时分配策略：

- 固定分配局部置换：在进程运行期间，物理块个数不变；新页面只能置换到已分配的物理块
- 可变分配全局置换：在进程运行期间，物理块个数随时变化；新页面可以向系统申请新的物理块
- 可变分配局部置换：在进程运行期间，物理块个数随时变化；新页面只能置换到已分配的物理块；系统动态调整数量。

#### 4.4 页面置换算法

&emsp;如果内存空间己被装满而又要装入新页时，必须按某种算法将内存中的一些页淘汰出去，以便调入新页，这个工作称为“页面置换”。选择被淘汰页的方法成为页面置换算法。

- **最佳置换算法**: 淘汰那些以后永不使用，或者是在最长时间内不再被访问的页

  - 无法实现的算法，只能作为其它置换算法的衡量标准

- **先进先出算法**：每次淘汰最先进入内存的页

  - 优点：简单，易于实现
  - 缺点：效率不高，可能产生“抖动”现象

- **先进先出算法**：每次淘汰最先进入内存的页

  - 优点：简单，易于实现
  - 缺点：效率不高，可能产生“抖动”现象

- **最近最久未使用（LRU）算法**：淘汰那些在最近一段时间里最久未被使用的一页

  - LRU 算法是较好的一个算法，但是开销太大，要求系统有较多的支持硬件(移位寄存器或栈)

- **改进型 Clock 置换算法**: 除了考虑到页面的使用情况外，还增加了置换代价，选择换出页面时，既要是未使用过的页面，又要是未被修改过的页面把同时满足两条件的页面作为首选被淘汰的页。
  - 该算法与简单 Clock 算法比较，可减少磁盘的 I/O 操作次数 ，但实现该算法本身的开销将有所增加

#### 4.5 抖动现象

- 进程的大部分时间，都用于页面的换进换出，而几乎不能再去做任何有效的工作，从而导致发生处理机利用率急剧下降，而趋于零的现象，我们称此时系统处于抖动状态。
- 产生抖动的原因:产生抖动的根本原因是，系统中进程的数量太多，因此分配给每个进程的物理块数量太少，使得每个进程在运行时频繁的发生缺页中断
- 工作集:所谓工作集就是指在某段时间间隔 ∆ 内，进程访问页面的集合。为了使进程有较低的缺页率，应在该段时间内把进程的全部工作集装入内存中

&emsp;预防抖动的策略：

- 采用局部置换策略
- 利用工作集算法防止抖动
- 利用“L=S”准则调节缺页率
- 挂起某些进程

### 5. 分段虚拟存储管理方式

#### 5.1 基本原理

- 分段虚拟存储管理原理同分页虚拟存储管理原理一样，在程序运行前，不必调入所有分段，只需先调入若干个分段便可启动运行。当所访问的段不在内存中时，可请求操作系统将所缺的段调入内存
- 分段虚拟存储管理中的段表包括：段名、段长、段的基址、存取方式、访问位、修改位、存在位、增补位和外存地址

#### 5.2 缺段中断

- 在分段虚拟存储管理系统中，如果访问的段不在内存中，系统将产生一个缺段中断，请求操作系统将该段调入到内存
- 缺段中断和缺页中断一样 ，但段是信息的逻辑单位，所以不可能出现一条指令和一组信息被分割在两个段里的情况

#### 5.3 段的共享

- 利用段的动态链接很容易实现段的共享，一个共享段在不同作业中可具有不同的段号
- 设立一张共享段表对段的共享进行集中管理

- 可重入代码又称为“纯代码”，是一种允许多个进程同时访问的代码。

## 第九章 操作系统接口

### 1. 基本概念

- 人与计算机进行交互的接口：操作系统
- 人与操作系统进行交互的接口：操作系统接口

### 2. 操作系统接口分类

- 命令接口：
  - 联机用户接口：面向联机用户的操作接口；
  - 脱机用户接口：面向脱机(批处理)用户的操作接口
- 图形用户接口：面向联机用户的操作接口；
- 程序接口：面向程序员的接口，程序可以直接调用操作系统的核心功能；

### 3. 联机命令接口

#### 3.1 基本介绍

- 基本形式：`Command param1 param2 ...`

例如：

```shell
ls -la
mv file1 file2
```

#### 3.2 实现原理

- 键盘终端处理程序
  - 接收用户从终端输入的字符
  - 字符缓冲
  - 字符回显
  - 屏幕编辑
- 命令解释程序
  - 负责实现对用户输入命令的解释，并转入相应命令处理程序去执行。

### 4. Shell 程序接口

- hell 编程（UNIX）
  - 利用 UNIX 操作系统提供的命令，将需要完成的命令按执行次序写成文件，形成所谓 shell 程序文件。
  - 执行这类文件，可以实现一批命令的自动执行。

&emsp;Hadoop 的 Shell 示例

```shell
#!/usr/bin/env bash

# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# The name of the script being executed.
HADOOP_SHELL_EXECNAME="hadoop"
MYNAME="${BASH_SOURCE-$0}"

## @description  build up the hadoop command's usage text.
## @audience     public
## @stability    stable
## @replaceable  no
function hadoop_usage
{
  hadoop_add_option "buildpaths" "attempt to add class files from build tree"
  hadoop_add_option "hostnames list[,of,host,names]" "hosts to use in slave mode"
  hadoop_add_option "loglevel level" "set the log4j level for this command"
  hadoop_add_option "hosts filename" "list of hosts to use in slave mode"
  hadoop_add_option "workers" "turn on worker mode"

  hadoop_add_subcommand "checknative" client "check native Hadoop and compression libraries availability"
  hadoop_add_subcommand "classpath" client "prints the class path needed to get the Hadoop jar and the required libraries"
  hadoop_add_subcommand "conftest" client "validate configuration XML files"
  hadoop_add_subcommand "credential" client "interact with credential providers"
  hadoop_add_subcommand "daemonlog" admin "get/set the log level for each daemon"
  hadoop_add_subcommand "dtutil" client "operations related to delegation tokens"
  hadoop_add_subcommand "envvars" client "display computed Hadoop environment variables"
  hadoop_add_subcommand "fs" client "run a generic filesystem user client"
  hadoop_add_subcommand "jar <jar>" client "run a jar file. NOTE: please use \"yarn jar\" to launch YARN applications, not this command."
  hadoop_add_subcommand "jnipath" client "prints the java.library.path"
  hadoop_add_subcommand "kerbname" client "show auth_to_local principal conversion"
  hadoop_add_subcommand "key" client "manage keys via the KeyProvider"
  hadoop_add_subcommand "trace" client "view and modify Hadoop tracing settings"
  hadoop_add_subcommand "version" client "print the version"
  hadoop_add_subcommand "kdiag" client "Diagnose Kerberos Problems"
  hadoop_generate_usage "${HADOOP_SHELL_EXECNAME}" true
}

## @description  Default command handler for hadoop command
## @audience     public
## @stability    stable
## @replaceable  no
## @param        CLI arguments
function hadoopcmd_case
{
  subcmd=$1
  shift

  case ${subcmd} in
    balancer|datanode|dfs|dfsadmin|dfsgroups|  \
    namenode|secondarynamenode|fsck|fetchdt|oiv| \
    portmap|nfs3)
      hadoop_error "WARNING: Use of this script to execute ${subcmd} is deprecated."
      subcmd=${subcmd/dfsgroups/groups}
      hadoop_error "WARNING: Attempting to execute replacement \"hdfs ${subcmd}\" instead."
      hadoop_error ""
      #try to locate hdfs and if present, delegate to it.
      if [[ -f "${HADOOP_HDFS_HOME}/bin/hdfs" ]]; then
        exec "${HADOOP_HDFS_HOME}/bin/hdfs" \
          --config "${HADOOP_CONF_DIR}" "${subcmd}"  "$@"
      elif [[ -f "${HADOOP_HOME}/bin/hdfs" ]]; then
        exec "${HADOOP_HOME}/bin/hdfs" \
          --config "${HADOOP_CONF_DIR}" "${subcmd}" "$@"
      else
        hadoop_error "HADOOP_HDFS_HOME not found!"
        exit 1
      fi
    ;;

    #mapred commands for backwards compatibility
    pipes|job|queue|mrgroups|mradmin|jobtracker|tasktracker)
      hadoop_error "WARNING: Use of this script to execute ${subcmd} is deprecated."
      subcmd=${subcmd/mrgroups/groups}
      hadoop_error "WARNING: Attempting to execute replacement \"mapred ${subcmd}\" instead."
      hadoop_error ""
      #try to locate mapred and if present, delegate to it.
      if [[ -f "${HADOOP_MAPRED_HOME}/bin/mapred" ]]; then
        exec "${HADOOP_MAPRED_HOME}/bin/mapred" \
        --config "${HADOOP_CONF_DIR}" "${subcmd}" "$@"
      elif [[ -f "${HADOOP_HOME}/bin/mapred" ]]; then
        exec "${HADOOP_HOME}/bin/mapred" \
        --config "${HADOOP_CONF_DIR}" "${subcmd}" "$@"
      else
        hadoop_error "HADOOP_MAPRED_HOME not found!"
        exit 1
      fi
    ;;
    checknative)
      HADOOP_CLASSNAME=org.apache.hadoop.util.NativeLibraryChecker
    ;;
    classpath)
      hadoop_do_classpath_subcommand HADOOP_CLASSNAME "$@"
    ;;
    conftest)
      HADOOP_CLASSNAME=org.apache.hadoop.util.ConfTest
    ;;
    credential)
      HADOOP_CLASSNAME=org.apache.hadoop.security.alias.CredentialShell
    ;;
    daemonlog)
      HADOOP_CLASSNAME=org.apache.hadoop.log.LogLevel
    ;;
    dtutil)
      HADOOP_CLASSNAME=org.apache.hadoop.security.token.DtUtilShell
    ;;
    envvars)
      echo "JAVA_HOME='${JAVA_HOME}'"
      echo "HADOOP_COMMON_HOME='${HADOOP_COMMON_HOME}'"
      echo "HADOOP_COMMON_DIR='${HADOOP_COMMON_DIR}'"
      echo "HADOOP_COMMON_LIB_JARS_DIR='${HADOOP_COMMON_LIB_JARS_DIR}'"
      echo "HADOOP_COMMON_LIB_NATIVE_DIR='${HADOOP_COMMON_LIB_NATIVE_DIR}'"
      echo "HADOOP_CONF_DIR='${HADOOP_CONF_DIR}'"
      echo "HADOOP_TOOLS_HOME='${HADOOP_TOOLS_HOME}'"
      echo "HADOOP_TOOLS_DIR='${HADOOP_TOOLS_DIR}'"
      echo "HADOOP_TOOLS_LIB_JARS_DIR='${HADOOP_TOOLS_LIB_JARS_DIR}'"
      if [[ -n "${QATESTMODE}" ]]; then
        echo "MYNAME=${MYNAME}"
        echo "HADOOP_SHELL_EXECNAME=${HADOOP_SHELL_EXECNAME}"
      fi
      exit 0
    ;;
    fs)
      HADOOP_CLASSNAME=org.apache.hadoop.fs.FsShell
    ;;
    jar)
      if [[ -n "${YARN_OPTS}" ]] || [[ -n "${YARN_CLIENT_OPTS}" ]]; then
        hadoop_error "WARNING: Use \"yarn jar\" to launch YARN applications."
      fi
      if [[ -z $1 || $1 = "--help" ]]; then
        echo "Usage: hadoop jar <jar> [mainClass] args..."
        exit 0
      fi
      HADOOP_CLASSNAME=org.apache.hadoop.util.RunJar
    ;;
    jnipath)
      hadoop_finalize
      echo "${JAVA_LIBRARY_PATH}"
      exit 0
    ;;
    kerbname)
      HADOOP_CLASSNAME=org.apache.hadoop.security.HadoopKerberosName
    ;;
    kdiag)
      HADOOP_CLASSNAME=org.apache.hadoop.security.KDiag
    ;;
    key)
      HADOOP_CLASSNAME=org.apache.hadoop.crypto.key.KeyShell
    ;;
    trace)
      HADOOP_CLASSNAME=org.apache.hadoop.tracing.TraceAdmin
    ;;
    version)
      HADOOP_CLASSNAME=org.apache.hadoop.util.VersionInfo
    ;;
    *)
      HADOOP_CLASSNAME="${subcmd}"
      if ! hadoop_validate_classname "${HADOOP_CLASSNAME}"; then
        hadoop_exit_with_usage 1
      fi
    ;;
  esac
}

# This script runs the hadoop core commands.

# let's locate libexec...
if [[ -n "${HADOOP_HOME}" ]]; then
  HADOOP_DEFAULT_LIBEXEC_DIR="${HADOOP_HOME}/libexec"
else
  bin=$(cd -P -- "$(dirname -- "${MYNAME}")" >/dev/null && pwd -P)
  HADOOP_DEFAULT_LIBEXEC_DIR="${bin}/../libexec"
fi

HADOOP_LIBEXEC_DIR="${HADOOP_LIBEXEC_DIR:-$HADOOP_DEFAULT_LIBEXEC_DIR}"
HADOOP_NEW_CONFIG=true
if [[ -f "${HADOOP_LIBEXEC_DIR}/hadoop-config.sh" ]]; then
  # shellcheck source=./hadoop-common-project/hadoop-common/src/main/bin/hadoop-config.sh
  . "${HADOOP_LIBEXEC_DIR}/hadoop-config.sh"
else
  echo "ERROR: Cannot execute ${HADOOP_LIBEXEC_DIR}/hadoop-config.sh." 2>&1
  exit 1
fi

# now that we have support code, let's abs MYNAME so we can use it later
MYNAME=$(hadoop_abs "${MYNAME}")

if [[ $# = 0 ]]; then
  hadoop_exit_with_usage 1
fi

HADOOP_SUBCMD=$1
shift

if hadoop_need_reexec hadoop "${HADOOP_SUBCMD}"; then
  hadoop_uservar_su hadoop "${HADOOP_SUBCMD}" \
    "${MYNAME}" \
    "--reexec" \
    "${HADOOP_USER_PARAMS[@]}"
  exit $?
fi

hadoop_verify_user_perm "${HADOOP_SHELL_EXECNAME}" "${HADOOP_SUBCMD}"

HADOOP_SUBCMD_ARGS=("$@")

if declare -f hadoop_subcommand_"${HADOOP_SUBCMD}" >/dev/null 2>&1; then
  hadoop_debug "Calling dynamically: hadoop_subcommand_${HADOOP_SUBCMD} ${HADOOP_SUBCMD_ARGS[*]}"
  "hadoop_subcommand_${HADOOP_SUBCMD}" "${HADOOP_SUBCMD_ARGS[@]}"
else
  hadoopcmd_case "${HADOOP_SUBCMD}" "${HADOOP_SUBCMD_ARGS[@]}"
fi

hadoop_add_client_opts

if [[ ${HADOOP_WORKER_MODE} = true ]]; then
  hadoop_common_worker_mode_execute "${HADOOP_COMMON_HOME}/bin/hadoop" "${HADOOP_USER_PARAMS[@]}"
  exit $?
fi

hadoop_subcommand_opts "${HADOOP_SHELL_EXECNAME}" "${HADOOP_SUBCMD}"

# everything is in globals at this point, so call the generic handler
hadoop_generic_java_subcmd_handler

```

### 5. 图形用户接口（GUI）

&emsp;利用图形图像展示计算机内部各类信息，列出任务菜单和图标可供选择；接受用户利用键盘、鼠标、输入板等设备的输入；系统根据当前输入的位置和输入具体内容，完成相应动作，并将结果以图形图象形式展示出来。

![alt text](images/5.2.png)

### 6. 程序接口

#### 6.1 系统调用的概念

&emsp;用户在程序中调用操作系统所提供的一些子功能。通常也把被调用的操作系统功能，称为系统调用。

```C
char buff[]=“abcde”;
for ( i=4; i>=0; i--)
  printf( “%c”, buff[i] ) ;
```

#### 6.2 系统调用的特点

&emsp;在系统中为控制系统调用服务的机构称为陷入（TRAP）或异常处理机构。相对应，把由于系统调用引起处理机中断的指令称为陷入或异常指令（或称访管指令）

> 系统调用和函数调用区别：
>
> - 进入和退出方式不同:
>   - 系统调用：INT/IRET，
>   - 函数调用：CALL/RET;
> - CPU 状态变化不同：
>   - 系统调用：用户态 → 系统态 → 用户态；
>   - 函数调用：无 CPU 状态变化。

#### 6.3 系统调用的实现

- 在操作系统中，每个系统调用都对应一个事先给定的功能号，例如 0、1、2、3 等;
- 在陷入指令中必须包括对应系统调用的功能号。有些陷入指令中，还
- 带有传给陷入处理机构和内部处理程序的有关参数;
- 必须为实现系统调用功能的子程序编造入口地址表，每个入口地址与相应的系统程序对应;
- 陷入处理程序把陷入指令包含功能号与入口地址表有关项对应, 系统调用功能号驱动有关子程序执行;
- 在系统调用处理结束之后，用户程序需利用系统调用返回结果,继续执行.
